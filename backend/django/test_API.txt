# ====================================================================
# TELEGRAM AUTHENTICATION FLOW TESTS
# = Requires: Django server running on 127.0.0.1:8000
# ====================================================================

# NOTE: Replace {{CODE}} and {{CHAT_ID}} with actual values as you test.
# Use environment variables or global variables in your REST client if possible.

@url = http://127.0.0.1:8000/api/auth

### 1. START UNIFIED FLOW (Initiate Registration/Login)
# This always creates a STATE_TYPE_REGISTRATION state.
# Response contains the {{CODE}} (one_time_code).

POST {{url}}/initiate/
Content-Type: application/json

{}

# Store the code from the response for the next step (Manual step: Open Telegram Deep Link)
# Example response: {"success": true, "one_time_code": "917a54cd-20ba-419d-8f53-9da1cd97f36d"}

### 2. TELEGRAM WEBHOOK CONFIRMATION (Simulated by Telegram Bot)
# The user must click the deep link in Telegram first.
# This simulates the webhook call the Telegram API sends back to your server.
# {{CHAT_ID}} is the user's unique Telegram Chat ID (e.g., 1085083058).

# Use the code obtained in step 1.
@code = 917a54cd-20ba-419d-8f53-9da1cd97f36d
@chat_id = 1085083058

# NOTE: In a real test, the deep link is clicked, triggering the webhook endpoint.
# Since we cannot easily simulate the /start deep link format here, we use the internal Verify API
# to set is_verified=True.

POST {{url}}/verify/
Content-Type: application/json

{
    "code": "{{code}}",
    "chat_id": "{{chat_id}}"
}
# Expected Response: 200 OK, message: "Telegram verification successful..."


### 3. CHECK STATUS (POLLING STEP 1: Registration Status Check)
# Check the status of the code. Since the user is new, this should return registered: False.

GET {{url}}/status/?code={{code}}
# Expected Status: 200 OK
# Expected Body (New User): {"status": "verified", "registered": false, ...}


### 4. FINAL REGISTRATION (NEW USER)
# Submits phone and names. This creates the final User account and returns JWT tokens.
# Note: username is auto-generated by the backend.

POST {{url}}/final/
Content-Type: application/json

{
    "code": "{{code}}",
    "phone_number": "5551234567",
    "first_name": "Test",
    "last_name": "User"
}
# Expected Status: 201 Created
# Store {{ACCESS_TOKEN}} and {{REFRESH_TOKEN}} from the response.
@access_token = {{response.body.access_token}}
@refresh_token = {{response.body.refresh_token}}


### 5. USER PROFILE CHECK (Test JWT Authentication)
# Uses the obtained access token to verify the session.

GET {{url}}/profile/
Authorization: Bearer {{access_token}}
# Expected Status: 200 OK
# Expected Body: {"username": "...", "user_id": ..., "telegram_linked": true, ...}


### ====================================================================
# EXISTING USER LOGIN FLOW TEST
# = This assumes the user from Step 4 exists and is now logging in.
# ====================================================================

### 6. START UNIFIED FLOW (Existing User Initiate)
# Creates a NEW registration state.
POST {{url}}/initiate/
Content-Type: application/json

{}
# Store the new code from the response for the login test.
@login_code = {{response.body.one_time_code}}

### 7. TELEGRAM WEBHOOK CONFIRMATION (Simulated by Telegram Bot)
# The existing user clicks the deep link containing {{login_code}}.
# The webhook internally treats this as a login confirmation (Case A fix).

POST {{url}}/verify/
Content-Type: application/json

{
    "code": "{{login_code}}",
    "chat_id": "{{chat_id}}"
}
# Expected Response: 200 OK

### 8. CHECK STATUS (POLLING STEP 2: Login Check)
# Check the status of the new code. Since the user is REGISTERED, this should return tokens immediately.

GET {{url}}/status/?code={{login_code}}
# Expected Status: 200 OK
# Expected Body (Existing User): {"status": "success", "registered": true, "access_token": "...", ...}